#!/usr/bin/env lua

local argparse = require "argparse"
local inspect = require "inspect"

local driver = require "pallene.driver"
local print_ir = require "pallene.print_ir"
local util = require "pallene.util"

-- List of optimizations that the Pallene compiler does. If a new optimization is made,
-- it should be added to this table.
local all_opt_passes = {"uninitialized", "constant_propagation"}

-- List of compiler passes that are available. If a new optimization is made,
-- it should be added to this table.
local dump_passes = {"ast", "checker", "ir", "uninitialized", "constant_propagation"}

local p = argparse("pallenec", "Pallene compiler")
p:argument("source_file", "File to compile")
p:mutex(
    p:flag("--emit-c", "Generate a .c file instead of an .so file"),
    p:flag("--emit-asm", "Generate a .s file instead of an .so file"),
    p:flag("--emit-lua", "Generate a .lua file instead of an .so file"),
    p:flag("--compile-c", "Compile a .c file generated by --emit-c"),
    p:flag("--print-ir", "Show a human-readable version of the program's IR"),
    p:option("--dump", "Print the result of an internal compiler pass"):choices(dump_passes)
)
p:option("--optimizations", "Pallene optimizations to be executed. If no optimization is listed, none is executed."):args("*")
    :choices(all_opt_passes)
local args = p:parse()

-- For compilation errors that don't happen inside a source file.
-- Inspired by gcc, eg. "gcc: fatal error: no input files".
local compiler_name = arg[0]

local function compile(in_ext, out_ext, opt_passes)
    local ok, errs = driver.compile(compiler_name, in_ext, out_ext, args.source_file, opt_passes)
    if not ok then util.abort(table.concat(errs, "\n")) end
end

local inspect_opts = {
    process = function(item, path)
        local key = path[#path]
        if key == inspect.METATABLE then
            return nil
        elseif type(key) == "string" and (key == "loc" or string.match(key, "_loc$")) then
            if args.show_locations then
                return item and string.format("%d:%d", item.line, item.col)
            else
                return nil
            end
        else
            return item
        end
    end
}

local function dump(filename, stop_after)
    local input, err = driver.load_input(filename)
    if err then util.abort(err) end

    local out, errs = driver.compile_internal(filename, input, stop_after)
    if not out then util.abort(table.concat(errs, "\n")) end

    print(inspect(out, inspect_opts))
    print(string.format("Exit after %s step", stop_after))
end

local function pretty_print_ir(filename)
    local input, err = driver.load_input(filename)
    if not input then util.abort(err) end

    local module, errs = driver.compile_internal(filename, input, "ir")
    if not module then util.abort(table.concat(errs, "\n")) end

    io.stdout:write(print_ir(module))
end

local flags = 0
if args.emit_c    then flags = flags + 1 end
if args.emit_asm  then flags = flags + 1 end
if args.compile_c then flags = flags + 1 end
if args.dump      then flags = flags + 1 end
if args.print_ir  then flags = flags + 1 end
if args.emit_lua  then flags = flags + 1 end

local opt_passes = {}
if args.optimizations then
    for _, opt in ipairs(args.optimizations) do
        opt_passes[opt] = true
    end
else
    for _, opt in ipairs(all_opt_passes) do
        opt_passes[opt] = true
    end
end

if     flags == 0     then compile("pln", "so", opt_passes)
elseif args.emit_c    then compile("pln", "c", opt_passes)
elseif args.emit_asm  then compile("c",   "s")
elseif args.compile_c then compile("c" ,  "so")
elseif args.dump      then dump(args.source_file, args.dump)
elseif args.print_ir  then pretty_print_ir(args.source_file)
elseif args.emit_lua  then compile("pln", "lua")
else
    error("impossible")
end
